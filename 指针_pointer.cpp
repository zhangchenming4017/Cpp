#include<iostream>
using namespace std;

int main()
{
	//***指针的定义***
	const long long m = 10;
	int* p1;
	long* p2;
	//long long* p3 = &m; //错误,“const long long*”类型不能用于初始化“long long*”类型的实体
	long long* p3;
	cout << "p1在内存中的长度为： " << sizeof p1 << endl;
	cout << "p2在内存中的长度为： " << sizeof p2 << endl;
	cout << "p3在内存中的长度为： " << sizeof p3 << endl;
	//结果均为8，因为在内存系统环境中地址为64位，所以作为存储地址的数据类型，指针的长度位8个字节

	//***指针的使用***
	int a = 10;
	int b = 20;
	long c = 30;
	
	p1 = &a; //p是指向a的指针
	p2 = &c;
	//指针的类型必须与存放的数据类型相匹配 因此p2 = &b 是错误的表达

	cout << "a的地址位：" << &a << endl;
	cout << "b的地址位：" << &b << endl;
	cout << "c的地址位：" << &c << endl;

	cout << "p1 = " << p1 << endl;
	cout << "p2 = " << p2 << endl;

	*p1 = 12; //“*”（解引用操作符）*p1等同于a
	cout << "a = " << a << endl; //结果位12

	p1 = &b;
	*p1 = 25; //将p1所指向的对象（b），修改为25
	cout << "a = " << a << endl; //结果位12
	cout << "b = " << b << endl; //结果为25

	//***无效指针 （野指针）***
	//int* pt1; //定义了一个指针后，如果不进行初始化，那么它的内容是不确定的（比如0xcccc）
	//*pt1 = 100;  //威胁，指针没有初始化，是无效指针，访问到的内容是不存在的对象，如果访问到系统核心内存区域，修改其中内容则会使系统奔溃
	//因此使用指针时，一定要先初始化，让它指向一个真实的对象。

	//***空指针***
	//空指针不指向任何对象
	int* np = nullptr; //空指针字面值
	np = NULL; //预处理变量
	np = 0;  //空指针所保存的其实就是0值，一般把它叫做“0地址”，这个地址也是内存中真实存在的，所有也不允许访问
	//这里所指的0地址并不是真实意义上的0所对应的那个字节，而是系统会把它解析成一个不表示任何数据的不被使用的内存地址

	int zero = 0;
	//np = zero;  //错误，int变量不能赋给指针

	//*** void*指针 ***
	int i = 100;
	char ch = 'a';
	string s = "hello";

	void* vp = &i;
	vp = &ch;
	vp = &s;
	// *vp;  //错误
	//void*指针只知道”保存了一个地址“，至于这个地址对应数据对象是什么类型并不清楚。所以不能通过void*指针访问对象

	cout << "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――-\n" << endl;
	//*** 指向指针的指针 ***
	int j = 1024;
	int* pj = &j;      //pj是一个指针，指向int类型的数据
	int** ppj = &pj;   //ppj是一个二级指针，指向一个int*类型的指针

	cout << "pj = " << pj << endl;
	
	cout << "*pj = " << *pj << endl;
	
	cout << "ppj = " << ppj << endl;
	
	cout << "*ppj = " << *ppj << endl;
	
	cout << "**ppj = " << **ppj << endl;
	//指针本身也是一个数据对象，也有自己的内存地址，所以可以用一个指针保存另一个指针的地址

	cout << "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――-\n" << endl;

	//*** 指向常量的指针 ***
	const int c1 = 13, c2 = 23;
	const int* pc = &c1;  //pc是指向int类型常量的指针，pc的类型为“const int*”
	cout << "*pc = " << *pc << endl;  //结果为13
	//*pc = 15; //错误，*pc等同于c1，而c1是一个整数型的常量，因此*pc也是一个常量，不能赋值
	pc = &c2;  //pc 是一个变量，变量可以是int类型常量的地址
	cout << "*pc = " << *pc << endl;  //结果为23
	
    //*** 指针常量（const指针） ***
	//int* const cp = &c1; //错误，“const int*”类型的值不能用于初始化“int* const”类型的实体
	int* const cp = &j;
	//cp = &a;
	*cp = 12;
	cout << "j = " << j << endl;

	//总结：指向常量的指针本身是个变量，但它所指的对象只能是常量
	//      指针常量本身是一个常量，但它所指的对象只能是变量

	//*** 指向常量的指针常量 ***
	const int* const ccp = &c1;
	//ccp = &c2; //错误
	//*ccp = 12; //错误

	cout << "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――-\n" << endl;
	
	//*** 指针与数组 ***

	//** 数组名 **
	//用到数组名时，编译器一般都会把它转换成指针，这个指针就指向数组的第一个元素，所以我们可以用数组名来给指针赋值。
	int arr[]{ 1,2,3,4,5 };
	cout << "arr = " << arr << endl;
	cout << "&arr[0] = " << &arr[0] << endl; //与arr的输出结果相同
	cout << "&arr[1] = " << &arr[1] << endl; //比arr[0]的地址大4，因为int类型的数组每个元素的大小占4个字节

	int* pia = arr;  //数组名本质上是指针
	//int arr2[5] = arr; //错误的，数组不能拷贝
	cout << "*pia = " << *pia << endl; //结果为1
	*pia = 100;
	//arr[0] = 100; //与上一行代码效果相同

	for (int num : arr)cout << num << '\t';
	cout << endl;

	//** 指针运算 **
	//如果对指针pia做加一操作，我们会发现它保存的地址直接加了4，这其实是指向了下一个int类型的数据对象
	cout << "pia = " << pia << endl;
	cout << "pia +1 = " << (pia + 1) << endl;
	cout << "arr +1 = " << (arr + 1) << endl;  //与上一行代码效果相同
	cout << "*(arr + 1) = " << *(arr + 1) << endl;
	//** 指针和数组下标 **
	*(pia + 1) = 256;
	*(arr + 3) = 126;
	//因为数组名就是指针，所以可以通过指针来访问数组元素，效果跟arr[0],arr[1]是一样的
	for (int num : arr)cout << num << '\t'; 
	//遍历元素所谓的“范围for循环”，其实就是让指针不停地后移依次访问元素
	cout << endl;

	cout << "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――-\n" << endl;

	//** 指针数组和数组指针 **
	//指针数组：一个数组，它的所有元素都是相同类型的指针
	//数组指针：一个指针，指向一个数组的指针

	int* pa[5]; //定义指针数组
	int(* ap)[5]; //定义数组指针

	cout << "pa在内存中的长度为：" << sizeof pa << endl; //结果为40（8*5）
	cout << "ap在内存中的长度为：" << sizeof ap << endl; //结果为8

	pa[0] = &j;
	pa[1] = arr;
	pa[2] = arr + 2;

	ap = &arr;  //ap指向的就是整个arr数组
	//ap = arr //错误，arr其实int*类型，ap是int*[5]类型（即指向有五个int类型元素的数组的指针）
	cout << "*ap = " << *ap << endl; //其实就是arr存放数据的地址，也是arr第一个元素的地址
	cout << "**ap = " << **ap << endl; // 结果为100，也就是arr[0]
	cout << "*(*ap + 1) = " << *(*ap + 1)<< endl; //结果为256，也就是arr[1]
	cout << "**ap + 1 = " << **ap + 1 << endl; //结果为101，因此要注意解引用和运算符的顺序
	system("pause");

}