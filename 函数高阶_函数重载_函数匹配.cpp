#include<iostream>
using namespace std;

void Fun(int& x) { cout << 1 << endl; }
void Fun(const int& x) { cout << 2 << endl; }

void f() { cout << 1 << endl; }
void f(int x) { cout << 2 << endl; }
void f(int x,int y) { cout << 3 << endl; }
void f(double x, double y = 1.5) { cout << 4 << endl; }

int main()
{
	// *** 函数匹配(确定调用哪个函数的过程) ***
	// 如果传入的实参跟形参类型不同，只能通过隐式类型转换变成需要的类型，函数也可以正常调用。
	int i = 10;
	const int j = 10;
	double I = 10;
	const double J = 10;
	Fun(i);		//"1"
	Fun(j);		//"2"
	Fun(I);		//"2"
	Fun(J);		//"2"
	Fun(3);		//"2"
	Fun(3.14);		//"2"

	f(3.14); //“4”
	// f(10, 3.14); 二义性调用
	/*
	（1）候选函数
		函数匹配的第一步，就是确定“候选函数”，也就是找到对应的重载函数集。
	候选函数的要求：
		1.与调用的函数同名。
		2.函数声明，在函数的调用点可见

	（2）可行函数
		接下来就是从候选函数中，选出跟传入的实参匹配的函数。这些函数就是“可行函数”
	可行函数的要求：
		1.形参个数与调用传入的实参数量相同（有默认实参的形参可忽略）
		2.每个函数的类型与对应的形参类型相同，或者可以转换成形参的类型

	（3）寻找最佳匹配
		在可行函数中，寻找最佳匹配。实参类型与形参类型越接近，它们就越匹配。所以能不进行转换就实际匹配的，要优于需要转换的。

	（4）多参数的函数匹配
		如果实参的数量不止一个，那么就需要逐个比较每个参数；同样，类型能够精准匹配的要优于需要转换的
	寻找最佳匹配的原则：
		1.如果可行函数的所有形参都能精准匹配实参，那么它就是最佳匹配
		2.如果没有全部精准匹配，那么当一个可行函数所有参数的匹配，都不比别的可行函数差、并且至少有一个参数要更优，那么它就是最佳匹配

	（5）二义性调用
		如果检查完所有实参后，有多个可行函数不分优劣，无法找到一个最佳匹配时，编译器就会报错。
	*/
}