#include<iostream>
#include<cmath>
#include<iomanip>
using namespace std;

int main()
{
	int a(15), b(35), c(0), d(1);
	float x(3), y(5), z(7);
	char w = '5';
	cout << "(a & b)=" << (a & b) << endl;//001111 & 100011 = 000011(3)
	cout << "(a <<2 )=" << (a << 2) << endl;
	cout << "(a | b)=" << (a | b) << endl;//001111 | 100011 = 101111(47)
	cout << "(a ^ b)=" << (a ^ b) << endl;//001111 ^ 100011 = 101100(44)
	cout << "(~a )=" << (~a) << endl; //~00001111 -(取反)- 11110000（-16）*仍有疑惑*
	cout << "(a && b)=" << (a && b) << endl;//输出为“1”
	cout << "(a || b)=" << (a || b) << endl;//输出为“1”
	cout << "(a || c)=" << (a || c) << endl;//输出为“1”
	cout << "(!c)=" << (!c) << endl;//输出为“1”
	cout << "(!d)=" << (!d) << endl;//输出为“0”
	//逻辑运算符“！”&&“”||“的操作数为布尔型，返回类型也为布尔型。
	bool m = fabs(a - b) < 1e-6;
	cout << "m = " << m << endl;//输出为‘0’
	int n = fabs(a - b) < 1e-6;
	cout << "n = " << n << endl;//输出为"0"
	cout << "(a << 2 )= " << (a << 2) << endl;//输出为60
	cout << "(a >> 2 )= " << (a >> 2) << endl;//输出值为3，并不是3.75，可见>>得到的结果为整型
	cout << "(a / z )= " << (a / z) << endl;//因为z为浮点型，所以输出值为2.14286，实际上结果应该是2.142857142857.....
	cout << setprecision(12) << "(a / z )= " << (a / z) << endl;//输出为2.14285707474，浮点型精度为7位,当设置精度偏大时，会补上无意义的小数
	cout << setprecision(6) << "(b / a )= " << (b / a) << endl;//输出为2，两整型相除为整型
	cout << "(a % w )= " << (a % w) << endl;//取余只能为整型或字符
	//++，--运算符
	int j = 5, k = ++j, h = j;
	cout << "j k h 分别等于=" << j << ',' << k << ',' << h << endl;//j先加一，再赋值，结果为6，6，6
	int jj = 5, kk = jj++, hh = jj;
	cout << "jj kk hh 分别等于=" << jj << ',' << kk << ',' << hh << endl;//jj先赋值，再加一，结果为6，5，6
	int s = 5, ss, sss; ss = s++; sss = s;
	cout << "s ss sss 分别等于=" << s << ',' << ss << ',' << sss << endl;//s先赋值，再加一，结果为6，5，6
	//++,--不能作用于常量和表达式。  （x+y）++，5++        
	cout << "(x / 0 )= " << (x / 0) << endl; //输出结果为inf（无限大），被除数必须为浮点型。
	//cout << "10 == 4 + 6" << 10 == 4 + 6 << endl;  运算符'=='的优先级过低，会报错
	cout << "10 == 4 + 6" << (10 == 4 + 6) << endl;
	//短路求值
	int i = 0;
	1 < 2 && ++i;
	cout << "i = " << i << endl;
	i = 0;
	1 > 2 && ++i;
	cout << "i = " << i << endl;
	/*位移运算符 一般用于无符号类型
	较小的整数类型（char，short,bool）会自动提升为int类型再做位移，得到的结果也是int类型（32位）
	*/
	unsigned char bits = 0xb5;//bin = 1011 0101, dec = 181
	cout << hex;
	cout << "bits左移2位： " << (bits << 2) << endl;
	//输出为 2d4 bin = 10 1101 0100, dec = 724 
	cout << "bits左移8位： " << (bits << 8) << endl;
	//输出为 b500 bin = 1011 0101 0000 0000, dec = 46336
	cout << "bits左移31位： " << (bits << 31) << endl;
	//输出为 8000 0000 bin = 1000 0000 0000 0000 0000 0000 0000 0000, dec = 2147483648 存在数据丢失
	cout << "bits左移32位： " << (bits << 32) << endl;
	//输出为 b5 bin = 1011 0101, dec = 181 因为int类型为32位，移动>=32时，会进行取余。
	cout << "bits左移34位： " << (bits << 34) << endl;
	//输出为 2d4 bin = 10 1101 0100, dec = 724 结果和左移2位相同
	/* 位逻辑运算符同样会把较小的整数类型转换成int类型
	   案例： 从一组数中找出只出现一次的数 */
	int n1(5), n2(9), n3(12), n4(9), n5(12);
	cout << "只出现一次的数为： " << (n1 ^ n2 ^ n3 ^ n4 ^ n5) << endl;//结果为5
	//原理： a^a = 0, a^0 = a
	// cout << (5 ^ 9 ^ 9 ^ 12 ^ 12 ^ 9) << end;  为什么这个为 c *疑惑*




}